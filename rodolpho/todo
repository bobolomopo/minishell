ft_read_line:
	write double-linked list funcions for libft and use them for history navigation

builtins:
	export (the no args case)

resolve_path:
	use shell_env PATH

shell:
	non-interactive shell case (use get_next_line)
		istty function

	signals: 
		-->	should I implement any other signal handler other than SIGINT and SIGQUIT ?

expander:
	parse_var_name: consider rewriting using is_valid_name, ft_strchr

env:
	SHLVL bigger than 9
	set PWD when the shell starts???
	the _ variable ??

	should I handle local vars?	this would affect what export VAR does (without =)
	should I really copy the envp? can't I just use it?
	

error handling: (ideas)
	function int free_ret(void *ptr, int ret) : frees ptr and returns ret (0 can be used for returning NULL pointer)

libft: 
	protect ft_free_split

NOTES:
	ctrl-c, ctrl-d, ctrl-\
	for some reason:
		read() does not read anything when ctr-c is pressed. SIGINT is sent.
			a non-builtcommand will be terminated by this signal, and the
			return value will be 130 (128 + 2)
		read() does not read anything when ctr-\ is pressed. SIGQUIT is sent.
			this signal must be ignored by the shell, but a non-builtcommand
			will be terminated by the signal. 
			The shell with display "Quit: 3\n"
			and the return value will be 131 (128 + 3)
		read() reads 4 when ctrl-d is pressed.


	expansion must be done right before execution
	of a simple command or pipeline.
	because of this: return_42; echo $? (must display 42, and not the value
	of $ before the command started)
	