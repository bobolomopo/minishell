Idea:
	Drop the t_command struct and use simply a char **argv containing arguments and redirections
	When running a command, after making variable expansion, use get_redirections to build a 
	list of redirections

ft_read_line:
	write double-linked list funcions for libft and use them for history navigation

shell:
	non-interactive shell case (use get_next_line)
		istty function

	signals: 
		-->	should I implement any other signal handler other than SIGINT and SIGQUIT ?

env:
	set PWD when the shell starts???
	the _ variable ??

	should I handle local vars?	this would affect what export VAR does (without =)
	should I really copy the envp? can't I just use it?


libft: 
	protect ft_free_split

NOTES:
	ctrl-c, ctrl-d, ctrl-\
	for some reason:
		read() does not read anything when ctr-c is pressed. SIGINT is sent.
			a non-builtcommand will be terminated by this signal, and the
			return value will be 130 (128 + 2)
		read() does not read anything when ctr-\ is pressed. SIGQUIT is sent.
			this signal must be ignored by the shell, but a non-builtcommand
			will be terminated by the signal. 
			The shell will display "Quit: 3\n"
			and the return value will be 131 (128 + 3)
		read() reads 4 when ctrl-d is pressed.

	memory management:
		a forked process leaks memory if it exits without freeing the heap.
		an execd process, ok, no problem (?), apparently.
		So, if exec returns, gotta clear memory before exiting.

	expansion must be done right before execution
	of a simple command or pipeline.
	because of this: return_42; echo $? (must display 42, and not the value
	of $ before the command started)
	

	export and env
		export lists all variables in env, including those whose value it the empty string
		env only displays the ones that have a values other than the empty string
	expander:
		a dollar-sign followed by and invalid name should be considered an ordinary
		'$' by the PARSER
