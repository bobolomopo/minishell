

ft_read_line:
	write double-linked list funcions for libft and use them for history navigation

builtins:
	export (the no args case)


shell:
	non-interactive shell case (use get_next_line)
		istty function

	signals: 
		-->	should I implement any other signal handler other than SIGINT and SIGQUIT ?

expander:
	parse_var_name: consider rewriting using is_valid_name, ft_strchr

	a dollar-sign followed by and invalid name should be considered an ordinary
	'$' by the PARSER


env:
	set PWD when the shell starts???
	the _ variable ??

	should I handle local vars?	this would affect what export VAR does (without =)
	should I really copy the envp? can't I just use it?
	

error handling: (ideas)
	function int free_ret(void *ptr, int ret) : frees ptr and returns ret (0 can be used for returning NULL pointer)

libft: 
	protect ft_free_split

NOTES:
	ctrl-c, ctrl-d, ctrl-\
	for some reason:
		read() does not read anything when ctr-c is pressed. SIGINT is sent.
			a non-builtcommand will be terminated by this signal, and the
			return value will be 130 (128 + 2)
		read() does not read anything when ctr-\ is pressed. SIGQUIT is sent.
			this signal must be ignored by the shell, but a non-builtcommand
			will be terminated by the signal. 
			The shell will display "Quit: 3\n"
			and the return value will be 131 (128 + 3)
		read() reads 4 when ctrl-d is pressed.

	memory management:
		a forked process leaks memory if it exits without freeing the heap.
		an execd process, ok, no problem (?), apparently.
		So, if exec returns, gotta clear memory before exiting.

	expansion must be done right before execution
	of a simple command or pipeline.
	because of this: return_42; echo $? (must display 42, and not the value
	of $ before the command started)
	

	export and env
		export lists all variables in env, including those whose value it the empty string
		env only displays the ones that have a values other than the empty string