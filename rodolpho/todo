read_line:

	deal with arrows left\right, ctrl-l

	ctrl-c, ctrl-d, ctrl-\
	for some reason:
		read() does not read anything when ctr-c is pressed. SIGINT is sent.
			a non-builtcommand will be terminated by this signal, and the
			return value will be 130 (128 + 2)
		read() does not read anything when ctr-\ is pressed. SIGQUIT is sent.
			this signal must be ignored by the shell, but a non-builtcommand
			will be terminated by the signal. 
			The shell with display "Quit: 3\n"
			and the return value will be 131 (128 + 3)
		read() reads 4 when ctrl-d is pressed.



executor:

	get return value from builtins and execd commands
		(struct containing char **shell_env and the special variables?)
	write builts
		start by the env ones

shell:

	non-interactive shell case (use get_next_line)
		istty function

	signals: 
		handle SIGINT and SIGQUIT in the shell (do not ignore)
		return values for execd process that were signaled (128 + signal)
			waitpd and its macros (see test)
		-->	should I implement any other signal handler other than SIGINT and SIGQUIT ?


expander:
	expansion and quote removal (?) must be done right before execution
	of a simple command or pipeline.
	because of this: return_42; echo $? (must display 42, and not the value
	of $ before the command started)


env:
	update PWD when cd