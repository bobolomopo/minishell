ft_read_line:
	deal with arrows left\right, ctrl-l

builtins:
	unset
	export (the no args case)

execution:
	use shell_env PATH

shell:

	non-interactive shell case (use get_next_line)
		istty function

	signals: 
		-->	should I implement any other signal handler other than SIGINT and SIGQUIT ?


expander:
	expansion and quote removal (?) must be done right before execution
	of a simple command or pipeline.
	because of this: return_42; echo $? (must display 42, and not the value
	of $ before the command started)

	parse_var_name: consider rewrite using is_valid_name, ft_strchr

env:
	set PWD when the shell starts???
	the _ variable
	OLDPWD ?

	should I handle local vars?	this would affect what env VAR does (without =)
	
NOTES:
	ctrl-c, ctrl-d, ctrl-\
	for some reason:
		read() does not read anything when ctr-c is pressed. SIGINT is sent.
			a non-builtcommand will be terminated by this signal, and the
			return value will be 130 (128 + 2)
		read() does not read anything when ctr-\ is pressed. SIGQUIT is sent.
			this signal must be ignored by the shell, but a non-builtcommand
			will be terminated by the signal. 
			The shell with display "Quit: 3\n"
			and the return value will be 131 (128 + 3)
		read() reads 4 when ctrl-d is pressed.

